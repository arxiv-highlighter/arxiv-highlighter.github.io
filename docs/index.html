<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>PDF highlighter</title>

  <style>
    html, body {
    height: 100%;
    width: 100%;
    margin: 0;
    /* overflow:hidden; */
    -webkit-overflow-scrolling: touch; 
    }
    </style>

</head>
<body>

<h1 id="main_title">Preparing to load the pdf...</h1>

<div id="container" style="width: 100vw; text-align:center;">
  <canvas id="canvas_page" style="border: 10px solid white; direction: ltr; display: none;"></canvas>
  <canvas id="canvas_annotation" style="border: 10px solid red; direction: ltr; display: none;"></canvas>
</div>

<script src="pdf.min.js"></script>
<script src="pdf.worker.min.js"></script>

<script id="script">

const main_title = document.getElementById('main_title');
const container = document.getElementById("container");
const canvas = document.getElementById("canvas_page");
// const annotation = document.getElementById("canvas_annotation");
const context = canvas.getContext("2d");
context.canvas.hidden = true;

var alpha;

canvas.style.position="absolute";
canvas.style.zIndex="-1";
canvas.style.top = "0";
canvas.style.left = "0";
canvas.style.margin = "0";
canvas.style.padding =  "0px";

canvas_annotation.style.position="absolute";
canvas_annotation.style.zIndex="99999";
canvas_annotation.style.top = canvas.style.top;
canvas_annotation.style.left = canvas.style.left;
canvas_annotation.style.margin = canvas.style.margin;
canvas_annotation.style.padding = canvas.style.padding;
 
var origin = null;
var final = null;
var all_rectangles = [];
var canvas_layer = 0;

var rect_colors = {'r':'red', 'g':"green", 'b':"blue", 'y':"yellow", 'o': "orange"};
const rect_colors_keys = Object.keys(rect_colors);
var next_color = 0;


var touchstartTime = 0;
var touchId = null;
var drawing = false;
var outputScale = 1;
var touchholdDelay;
var changeColor = false;


function create_new_canvas(){
  canvas_layer += 1;
  tmp_canvas = document.createElement("canvas");
  container.appendChild(tmp_canvas);
  tmp_canvas.width = canvas.width;
  tmp_canvas.height = canvas.height;
  tmp_canvas.style.width = canvas.style.width;
  tmp_canvas.style.height = canvas.style.height;
  tmp_canvas.style.position="absolute";
  tmp_canvas.style.zIndex=canvas_layer;
  tmp_canvas.style.top = canvas.style.top;
  tmp_canvas.style.left = canvas.style.left;
  tmp_canvas.style.margin = canvas.style.margin;
  tmp_canvas.style.padding =  canvas.style.padding;
  tmp_canvas.style.border = canvas.style.border;
  console.log("Creating canvas number: " + canvas_layer);
  return tmp_canvas.getContext("2d");
}


function load_rectangles(rectangles){
  tmp_context = create_new_canvas();
  for(let rectangle of rectangles){
    const tmp_color = rect_colors[rectangle.slice(1,-1).split(',')[0]];
    tmp_context.globalAlpha = alpha;
    tmp_context.fillStyle = tmp_color;
    const rect_values =  rectangle.slice(1,-1).split(',').slice(1,5).map(Number);
    tmp_context.beginPath();
    tmp_context.fillRect(canvas.width*rect_values[0]/outputScale, canvas.height*rect_values[1]/outputScale, 
                         canvas.width*(rect_values[2] - rect_values[0])/outputScale, canvas.height*(rect_values[3] - rect_values[1])/outputScale); 
    tmp_context.stroke();
    console.log("Color: " + tmp_color + " - " + "Values: " + rect_values);
  }
}

async function getFromUrl(defaultType = 'application/x-pdf'){
  const queryString = window.location.search;
  const urlParams = new URLSearchParams(queryString);
  var url = urlParams.get('url');
  const local_file = urlParams.get('local');
  if (url){
    console.log("Found url: " + url);
  } else if (local_file) {
    url = local_file;
    console.log("Found local file: " + url);
  } else {
    main_title.textContent = "Missing url or local pdf file!";
    console.log("Missing url or local pdf file!");
    return;
  }

  var page_num = urlParams.getAll('page')[0];
  if (!page_num){
    page_num = 1;
  }

  alpha = urlParams.getAll('alpha')[0];
  if (!alpha){
    alpha = 0.3;
  }

  touchholdDelay = urlParams.getAll('delay')[0];
  if (!touchholdDelay){
    touchholdDelay = 300;
  }


  all_rectangles = urlParams.getAll('rectangle') ? urlParams.getAll('rectangle') : [];
  
  // https://javascript.info/fetch-progress
  // Step 1: start the fetch and obtain a reader
  let response;
  try {
    response = await fetch(url);
  } catch (e){
    main_title.textContent = `Error fetching file ${url}`;
    console.log(e);
    return;
  }

  const fakereader = response.body.getReader();
  // Step 2: get total length
  const contentLength = +response.headers.get('Content-Length');
  // Step 3: read the data
  let receivedLength = 0; // received that many bytes at the moment
  let chunks = []; // array of received binary chunks (comprises the body)
  while(true) {
    const {done, value} = await fakereader.read();
    if (done) {
      break;
    }
    chunks.push(value);
    receivedLength += value.length;
    main_title.textContent = `Loading pdf (${parseInt(100*(receivedLength/contentLength))}%) - received ${receivedLength} of ${contentLength} bytes`;
  }

  // Step 4: concatenate chunks into single Uint8Array
  let chunksAll = new Uint8Array(receivedLength); // (4.1)
  let position = 0;
  for(let chunk of chunks) {
    chunksAll.set(chunk, position); // (4.2)
    position += chunk.length;
  }

  // const data = await response.blob();
  const data = new Blob([chunksAll]);
  main_title.style.display = "none";

  const reader = new FileReader();
  reader.readAsDataURL(data);
  return new Promise(resolve => {
    reader.onloadend = () => {
      resolve([reader.result, page_num]);
    };
  });
}

  //
  // The workerSrc property shall be specified.
  //

  //
  // Asynchronous download PDF
  //
  (async () => {
    const urlres = await getFromUrl();
    if (!urlres){
      return;
    }
    const loadingTask = await pdfjsLib.getDocument(urlres[0]);
    const pdf = await loadingTask.promise;
    //
    // Fetch the page
    //
    const page = await pdf.getPage(parseInt(urlres[1]));
    var desiredWidth = container.clientWidth - canvas.style.border.split(" ")[0].slice(0,-2)*2;
    var viewport = page.getViewport({ scale: 1, });
    var scale = desiredWidth / viewport.width;
    viewport = page.getViewport({ scale: scale, });

    // Support HiDPI-screens.
    outputScale = window.devicePixelRatio || 1;

    //
    // Prepare canvas using PDF page dimensions
    //

    canvas.width = Math.floor(viewport.width * outputScale);
    canvas.height = Math.floor(viewport.height * outputScale);
    canvas.style.width = Math.floor(viewport.width) + "px";
    canvas.style.height = Math.floor(viewport.height) + "px";

    canvas_annotation.width = canvas.width;
    canvas_annotation.height = canvas.height;
    canvas_annotation.style.width = canvas.style.width;
    canvas_annotation.style.height = canvas.style.height;
    canvas_annotation.style.left = canvas.style.left

    const transform = outputScale !== 1 
      ? [outputScale, 0, 0, outputScale, 0, 0] 
      : null;

    //
    // Render PDF page into canvas context
    //
    const renderContext = {
      canvasContext: context,
      transform,
      viewport,
    };
    page.render(renderContext);
    context.canvas.hidden = false;
    canvas.style.display = "block";
    canvas_annotation.style.display = "block";

    if (all_rectangles.length){
      load_rectangles(all_rectangles);
    }

    var tmp_canvas;
    var tmp_annotation;

    // https://stackoverflow.com/a/48579537/7658422
    if (window.matchMedia('(hover: hover), (any-hover: hover), (-moz-touch-enabled: 0)').matches) {
      console.log("Mouse detected...");
      canvas_annotation.addEventListener('mousedown', function(e) {
      if (e.button==0){
        origin = {x: e.offsetX/canvas.width, y: e.offsetY/canvas.height}; 
        tmp_annotation = create_new_canvas();
      }else if(e.button==2){
        //change color
        next_color++;
        const tmp_key = rect_colors_keys[(next_color % rect_colors_keys.length + rect_colors_keys.length) % rect_colors_keys.length];
        canvas_annotation.style.borderColor = rect_colors[tmp_key];
        console.log("Color changed to " + rect_colors[tmp_key]);
      }

    }, false);

    canvas_annotation.addEventListener('mousemove', function(e) {
      if (e.button!=0) return;
      if (!!origin) { 
        if (!!final) { 
          tmp_annotation.clearRect(0, 0, canvas.width, canvas.height);
        }
          tmp_annotation.globalAlpha = alpha;
          tmp_annotation.fillStyle = canvas_annotation.style.borderColor;
          final = {x: e.offsetX/canvas.width, y: e.offsetY/canvas.height}; 
          tmp_annotation.beginPath();
          tmp_annotation.fillRect(canvas.width*origin.x, canvas.height*origin.y, canvas.width*(final.x - origin.x), canvas.height*(final.y - origin.y)); 
          tmp_annotation.stroke(); 
        } 
    }, false);

    window.addEventListener('mouseup', function(e) {
      if (e.button!=0) return;
      if (!!final) {
        window.history.pushState("", document.title, window.location.href + "&rectangle=[" +
                                                          canvas_annotation.style.borderColor[0] + "," +
                                                          origin.x.toFixed(2) + "," +
                                                          origin.y.toFixed(2) + "," +
                                                          final.x.toFixed(2)  + "," +
                                                          final.y.toFixed(2) + "]"
                                                          );
      }
      origin = null; 
      final = null; 
    }, false);

    } else {
      console.log("Touch detected...");
      canvas_annotation.addEventListener('touchstart', function(e) {
      if(e.touches.length == 1) {
        touchstartTime = new Date().getTime();
        touchId = e.touches[0].touchId;
        const offsetX = outputScale*e.touches[0].pageX - 20; //10px border
        const offsetY = outputScale*e.touches[0].pageY - 20; //10px border
        origin = {x: outputScale*offsetX/canvas.width, y: outputScale*offsetY/canvas.height};
        console.log("Touch start!")
      } else if (e.touches.length == 2) {
        changeColor = true;
      }
    }, false);

    canvas_annotation.addEventListener('touchmove', function(e) {
      if (e.touches.length == 2) {
        changeColor = false; // avoid changing color during zoom
      }

      if(e.touches.length == 1 && touchstartTime > 0 && touchId == e.touches[0].touchId) {
        if (((new Date().getTime()) - touchstartTime ) > touchholdDelay){
          e.preventDefault();
          touchstartTime = 0;
          drawing = true;
          tmp_annotation = create_new_canvas();
          console.log("Starting rectangle...");
        } else {
          touchstartTime = 0; // to prevent starting while scrolling, etc
        }
      }
      if (drawing) {
        e.preventDefault();
        if (!!origin) { 
        if (!!final) { 
          tmp_annotation.clearRect(0, 0, canvas.width, canvas.height);
        }
          tmp_annotation.globalAlpha = alpha;
          tmp_annotation.fillStyle = canvas_annotation.style.borderColor;
          const offsetX = outputScale*e.touches[0].pageX - 20; //10px border
          const offsetY = outputScale*e.touches[0].pageY - 20; //10px border
          final = {x: outputScale*offsetX/canvas.width, y: outputScale*offsetY/canvas.height}; 
          tmp_annotation.beginPath();
          tmp_annotation.fillRect(canvas.width*origin.x/outputScale, canvas.height*origin.y/outputScale, 
                                  canvas.width*(final.x - origin.x)/outputScale, canvas.height*(final.y - origin.y)/outputScale); 
          tmp_annotation.stroke(); 
        }
      }
    }, false);

    canvas_annotation.addEventListener('touchend', function(e) {
      if (changeColor) {
        changeColor = false;
        //change color
        next_color++;
        const tmp_key = rect_colors_keys[(next_color % rect_colors_keys.length + rect_colors_keys.length) % rect_colors_keys.length];
        canvas_annotation.style.borderColor = rect_colors[tmp_key];
        console.log("Color changed to " + rect_colors[tmp_key]);
      }

      if (drawing){
        e.preventDefault();
        if (!!final) { 
          window.history.pushState("", document.title, window.location.href + "&rectangle=[" +
                                                            canvas_annotation.style.borderColor[0] + "," +
                                                            origin.x.toFixed(2) + "," +
                                                            origin.y.toFixed(2) + "," +
                                                            final.x.toFixed(2)  + "," +
                                                            final.y.toFixed(2) + "]"
                                                            );
        }
        origin = null; 
        final = null; 
        drawing = false;
        console.log("Rectangle finished!");
      }
    }, false);

    }

})();
</script>

</body>
</html>